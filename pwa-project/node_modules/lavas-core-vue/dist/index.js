'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _renderer = require('./renderer');

var _renderer2 = _interopRequireDefault(_renderer);

var _configReader = require('./config-reader');

var _configReader2 = _interopRequireDefault(_configReader);

var _prodBuilder = require('./builder/prod-builder');

var _prodBuilder2 = _interopRequireDefault(_prodBuilder);

var _devBuilder = require('./builder/dev-builder');

var _devBuilder2 = _interopRequireDefault(_devBuilder);

var _middlewareComposer = require('./middleware-composer');

var _middlewareComposer2 = _interopRequireDefault(_middlewareComposer);

var _logger = require('./utils/logger');

var _logger2 = _interopRequireDefault(_logger);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LavasCore extends _events2.default {
    constructor(cwd = process.cwd()) {
        super();
        this.cwd = cwd;
    }

    /**
     * invoked before build & runAfterBuild, do something different in each senario
     *
     * @param {string} env NODE_ENV
     * @param {boolean} isInBuild is in build process
     * @param {Object} options options
     * @param {string} options.config custom config file absolute path
     */
    init(env, isInBuild, options = {}) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            _this.env = env;
            _this.isProd = _this.env === 'production';
            _this.configReader = new _configReader2.default(_this.cwd, _this.env, options.config);

            if (!process.env.NODE_ENV) {
                process.env.NODE_ENV = env;
            }

            /**
             * in a build process, we need to read config by scan a directory,
             * but for online server after build, we just read config.json directly
             */
            if (isInBuild) {
                // scan directory
                _this.config = yield _this.configReader.read();
            } else {
                // read config from config.json
                _this.config = yield _this.configReader.readConfigFile();
            }

            _this.middlewareComposer = new _middlewareComposer2.default(_this);
            _this.renderer = new _renderer2.default(_this);
            _this.builder = _this.isProd ? new _prodBuilder2.default(_this) : new _devBuilder2.default(_this);

            // expose Koa & express middleware factory function
            _this.koaMiddleware = _this.middlewareComposer.koa.bind(_this.middlewareComposer);
            _this.expressMiddleware = _this.middlewareComposer.express.bind(_this.middlewareComposer);

            // expose render function
            _this.render = _this.renderer.render.bind(_this.renderer);

            if (!_this.isProd) {
                // register rebuild listener
                _this.on('start-rebuild', (0, _asyncToGenerator3.default)(function* () {
                    // read config again
                    let newConfig = yield _this.configReader.read();

                    // init builder again
                    _this.builder.init(newConfig);

                    // clean middlewares
                    _this.middlewareComposer.reset(newConfig);

                    // notify the server that it needs to restart
                    _this.emit('rebuild');
                }));
            }
        })();
    }

    /**
     * build in dev & prod mode
     *
     */
    build() {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            try {
                yield _this2.builder.build();
            } catch (e) {
                console.error(e);
                _logger2.default.error('build', `${_this2.env} build failed.`);
            }
        })();
    }

    /**
     * must run after build in prod mode
     *
     */
    runAfterBuild() {
        var _this3 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            // create with bundle & manifest
            yield _this3.renderer.createWithBundle();
        })();
    }

    /**
     * close builder in development mode
     *
     */
    close() {
        var _this4 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            yield _this4.builder.close();
            console.log('[Lavas] lavas closed.');
        })();
    }

    /**
     * add flag to req which will be ignored by lavas middlewares
     *
     * @param {Request} req req
     */
    ignore(req) {
        req.lavasIgnoreFlag = true;
    }
}
exports.default = LavasCore; /**
                              * @file index.js
                              * @author lavas
                              */

module.exports = exports['default'];