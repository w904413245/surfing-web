'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _fsExtra = require('fs-extra');

var _path = require('path');

var _workboxBuild = require('workbox-build');

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _constants = require('../constants');

var _webpack = require('../utils/webpack');

var _path2 = require('../utils/path');

var _logger = require('../utils/logger');

var _logger2 = _interopRequireDefault(_logger);

var _baseBuilder = require('./base-builder');

var _baseBuilder2 = _interopRequireDefault(_baseBuilder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ProdBuilder extends _baseBuilder2.default {
    constructor(core) {
        super(core);
        this.writeFile = _fsExtra.outputFile;
    }

    /**
     * build in production mode
     */
    build() {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            let { build, globals, serviceWorker } = _this.config;
            let serviceWorkerEnable = serviceWorker.enable;

            // clear dist/ first
            _logger2.default.info('build', `Ready to clean ${build.path}...`, true);
            yield (0, _fsExtra.emptyDir)(build.path);
            _logger2.default.info('build', `${build.path} cleaned`, true);

            _logger2.default.info('build', 'Auto generating routes...', true);
            yield _this.routeManager.buildRoutes();
            _logger2.default.info('build', 'Auto generating routes complete', true);

            _logger2.default.info('build', 'Writing temp files', true);
            yield _promise2.default.all([_this.writeRuntimeConfig(), _this.writeMiddleware(), _this.writeStore()]);
            _logger2.default.info('build', 'Writing temp files complete', true);

            // SSR build process
            if (build.ssr) {

                // create config for both client & server side
                let clientConfig = yield _this.createSSRClientConfig();
                let serverConfig = yield _this.createSSRServerConfig();

                // build bundle renderer
                yield _this.renderer.build(clientConfig, serverConfig);

                // serviceWorker.enable maybe changed during setting webpack config
                if (serviceWorker.enable !== serviceWorkerEnable) {
                    yield _this.writeRuntimeConfig();
                }

                /**
                 * when running online server, renderer needs to use template and
                 * replace some variables such as meta, config in it. so we need
                 * to store some props in config.json.
                 * NOTE: not all the props in config is needed. for now, only manifest
                 * & assetsDir are required. some props such as globalDir are useless.
                 */
                yield (0, _fsExtra.copy)(_this.lavasPath(_constants.CONFIG_FILE), (0, _path2.distLavasPath)(build.path, _constants.CONFIG_FILE));

                /**
                 * Don't use copy-webpack-plugin to copy this kind of files,
                 * otherwise these files will be added in the compilation of webpack.
                 * It will let some plugins such as vue-ssr-client misuse them.
                 * So just use fs.copy in such senario.
                 */
                if (build.ssrCopy) {
                    yield _promise2.default.all(build.ssrCopy.map((() => {
                        var _ref = (0, _asyncToGenerator3.default)(function* ({ src, dest = src, options = {} }) {
                            yield (0, _fsExtra.copy)((0, _path.join)(globals.rootDir, src), (0, _path.join)(build.path, dest), options);
                        });

                        return function (_x) {
                            return _ref.apply(this, arguments);
                        };
                    })()));
                }
            }
            // SPA build process
            else {
                    yield (0, _webpack.webpackCompile)((yield _this.createSPAConfig()), build.stats);
                }

            if (serviceWorker.enable !== false) {
                // Copy workbox files to dist/static/workbox-v3.*.*/
                yield (0, _workboxBuild.copyWorkboxLibraries)((0, _path.join)(build.path, _constants.ASSETS_DIRNAME_IN_DIST));
            }
        })();
    }
}
exports.default = ProdBuilder; /**
                                * @file DevBuilder
                                * @author lavas
                                */

module.exports = exports['default'];