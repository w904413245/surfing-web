'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _lodash = require('lodash.template');

var _lodash2 = _interopRequireDefault(_lodash);

var _fsExtra = require('fs-extra');

var _path = require('path');

var _htmlWebpackPlugin = require('html-webpack-plugin');

var _htmlWebpackPlugin2 = _interopRequireDefault(_htmlWebpackPlugin);

var _vueSkeletonWebpackPlugin = require('vue-skeleton-webpack-plugin');

var _vueSkeletonWebpackPlugin2 = _interopRequireDefault(_vueSkeletonWebpackPlugin);

var _clientPlugin = require('vue-server-renderer/client-plugin');

var _clientPlugin2 = _interopRequireDefault(_clientPlugin);

var _ommitCssWebpackPlugin = require('../plugins/ommit-css-webpack-plugin');

var _ommitCssWebpackPlugin2 = _interopRequireDefault(_ommitCssWebpackPlugin);

var _constants = require('../constants');

var _path2 = require('../utils/path');

var _webpack = require('../utils/webpack');

var _json = require('../utils/json');

var JsonUtil = _interopRequireWildcard(_json);

var _template = require('../utils/template');

var _template2 = _interopRequireDefault(_template);

var _logger = require('../utils/logger');

var _logger2 = _interopRequireDefault(_logger);

var _routeManager = require('../route-manager');

var _routeManager2 = _interopRequireDefault(_routeManager);

var _webpack2 = require('../webpack');

var _webpack3 = _interopRequireDefault(_webpack2);

var _configReader = require('../config-reader');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @file BaseBuilder
 * @author lavas
 */

class BaseBuilder {
    constructor(core) {
        this.core = core;
        this.env = core.env;
        this.cwd = core.cwd;
        this.renderer = core.renderer;
        this.webpackConfig = new _webpack3.default(core.config, this.env);
        this.routeManager = new _routeManager2.default(core.config, this.env);

        // will be overrided by subclass
        this.writeFile = null;

        this.init(core.config);
    }

    /**
     * do some initialization stuffs,
     * will be called later by rebuild in dev mode
     *
     * @param {Object} config config
     */
    init(config) {
        this.processConfig(config);
        this.config = config;
        this.webpackConfig.config = config;
        this.routeManager.config = config;
    }

    /**
     * process config
     *
     * @override
     */
    processConfig() {}

    /**
     * build
     *
     * @override
     */
    build() {
        throw new Error('[Lavas] Builder.build() must be overrided.');
    }

    /**
     * close
     *
     * @override
     */
    close() {}

    /**
     * resolve path relative to ./templates
     *
     * @param {string} path relative path of file
     * @return {string} resolvedPath absolute path of file
     */
    templatesPath(path = '/') {
        return (0, _path.join)(__dirname, '../templates', path);
    }

    /**
     * resolve path relative to ./.lavas
     *
     * @param {string} path relative path of file
     * @return {string} resolvedPath absolute path of file
     */
    lavasPath(path = '/') {
        return (0, _path.join)(this.config.globals.rootDir, './.lavas', path);
    }

    /**
     * write file to /.lavas directory
     *
     * @param {string} path relative path of file
     * @param {string} content content of file
     * @return {string} resolvedPath absolute path of file
     */
    writeFileToLavasDir(path, content) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            let resolvedPath = _this.lavasPath(path);
            yield _this.writeFile(resolvedPath, content);
            return resolvedPath;
        })();
    }

    /**
     * write config used in runtime
     */
    writeRuntimeConfig() {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            let filteredConfig = JsonUtil.deepPick(_this2.config, _configReader.RUMTIME_ITEMS);
            yield _this2.writeFileToLavasDir(_constants.CONFIG_FILE, JsonUtil.stringify(filteredConfig, null, 4));
        })();
    }

    writeMiddleware() {
        var _this3 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            const middlewareTemplate = _this3.templatesPath('middleware.tmpl');
            let isEmpty = !(0, _fsExtra.pathExistsSync)((0, _path.join)(_this3.config.globals.rootDir, 'middlewares'));

            yield _this3.writeFileToLavasDir('middleware.js', (0, _lodash2.default)((yield (0, _fsExtra.readFile)(middlewareTemplate, 'utf8')))({
                isEmpty
            }));
        })();
    }

    writeStore() {
        var _this4 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            const storeTemplate = _this4.templatesPath('store.tmpl');
            let isEmpty = !(0, _fsExtra.pathExistsSync)((0, _path.join)(_this4.config.globals.rootDir, 'store'));

            yield _this4.writeFileToLavasDir(_constants.STORE_FILE, (0, _lodash2.default)((yield (0, _fsExtra.readFile)(storeTemplate, 'utf8')))({
                isEmpty
            }));
        })();
    }

    /**
     * write an entry file for skeleton components
     *
     * @param {Array} skeletons routes for skeletons
     * @return {string} entryPath
     */
    writeSkeletonEntry(skeletons) {
        var _this5 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            const skeletonEntryTemplate = _this5.templatesPath('entry-skeleton.tmpl');

            return yield _this5.writeFileToLavasDir('skeleton.js', (0, _lodash2.default)((yield (0, _fsExtra.readFile)(skeletonEntryTemplate, 'utf8')))({ skeletons }));
        })();
    }

    /**
     * use html webpack plugin
     *
     * @param {Object} spaConfig spaConfig
     * @param {string} baseUrl baseUrl from config/router
     * @return {string} resolvedTemplatePath html template's path
     */
    addHtmlPlugin(spaConfig, baseUrl = '/') {
        var _this6 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            // allow user to provide a custom HTML template
            let { globals: { rootDir }, skeleton: { enable: enableSkeleton, asyncCSS }, build: { cssExtract } } = _this6.config;
            let htmlFilename;
            let templatePath;
            let tempTemplatePath;

            htmlFilename = `${_constants.DEFAULT_ENTRY_NAME}.html`;

            // find core/spa.html.tmpl
            templatePath = (0, _path.join)(rootDir, `core/${_constants.SPA_TEMPLATE_HTML}`);
            if (!(0, _fsExtra.pathExistsSync)(templatePath)) {
                // find core/index.html.tmpl
                templatePath = (0, _path.join)(rootDir, `core/${_constants.TEMPLATE_HTML}`);
            }

            if (!(0, _fsExtra.pathExistsSync)(templatePath)) {
                throw new Error(`${_constants.SPA_TEMPLATE_HTML} or ${_constants.TEMPLATE_HTML} required`);
            }

            tempTemplatePath = (0, _path.basename)(templatePath);

            // write HTML template used by html-webpack-plugin which doesn't support template STRING
            let resolvedTemplatePath = yield _this6.writeFileToLavasDir(tempTemplatePath, _template2.default.client((yield (0, _fsExtra.readFile)(templatePath, 'utf8')), baseUrl));

            /**
             * don't inject <link rel=stylesheet> in head,
             * use <link rel=preload> to load CSS asynchronously instead
             * https://github.com/lavas-project/lavas/issues/73
             */
            let entryClientContent = yield (0, _fsExtra.readFile)((0, _path.join)(rootDir, 'core/entry-client.js'), 'utf8');
            let shouldUpdateLavasTemplate = entryClientContent.indexOf('window.mountLavas') === -1;
            let enableAsyncCSS = asyncCSS && enableSkeleton && cssExtract;
            _this6.config.enableAsyncCSS = enableAsyncCSS && !shouldUpdateLavasTemplate;
            if (enableAsyncCSS) {
                if (shouldUpdateLavasTemplate) {
                    _logger2.default.warn('build', 'If you want to render Skeleton faster, please update `entry-client.js`. You can refer to https://github.com/lavas-project/lavas/issues/73.');
                } else {
                    spaConfig.plugin('ommit-css').use(_ommitCssWebpackPlugin2.default);
                }
            }

            // add html webpack plugin
            spaConfig.plugin('html').use(_htmlWebpackPlugin2.default, [{
                filename: htmlFilename,
                template: resolvedTemplatePath,
                inject: true,
                minify: {
                    removeComments: true,
                    collapseWhitespace: true,
                    removeAttributeQuotes: true
                },
                favicon: (0, _path2.assetsPath)('img/icons/favicon.ico'),
                chunksSortMode: 'dependency',
                cache: false,
                chunks: ['manifest', 'vue', 'vendor', _constants.DEFAULT_ENTRY_NAME],
                config: _this6.config // use config in template
            }]);

            return { resolvedTemplatePath, tempTemplatePath };
        })();
    }

    /**
     * use vue-skeleton-webpack-plugin
     *
     * @param {Object} spaConfig spaConfig
     */
    addSkeletonPlugin(spaConfig) {
        var _this7 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            let { router, skeleton } = _this7.config;
            // if skeleton provided, we need to create an entry
            let skeletonConfig;

            // add default skeleton path `@/core/Skeleton.vue`
            if (!skeleton.routes || !skeleton.routes.length) {
                skeleton.routes = [{
                    path: '*',
                    componentPath: _constants.DEFAULT_SKELETON_PATH
                }];
            }

            // check if all the componentPaths are existed first
            let error = yield _this7.validateSkeletonRoutes(skeleton.routes, spaConfig.resolve.alias.entries());
            if (error && error.msg) {
                console.error(error.msg);
            } else {
                // generate skeletonId based on componentPath
                skeleton.routes.forEach(function (route) {
                    route.componentName = (0, _path.basename)(route.componentPath, '.vue');
                    route.componentNameInDash = (0, _path2.camelCaseToDash)(route.componentName);
                    route.skeletonId = route.skeletonId || route.componentNameInDash;
                });

                // marked as supported at this time
                _this7.skeletonEnabled = true;

                let skeletonEntryPath = yield _this7.writeSkeletonEntry(skeleton.routes);

                // when ssr skeleton, we need to extract css from js
                skeletonConfig = yield _this7.webpackConfig.server({
                    cssExtract: true,
                    extendWithWebpackChain: function (serverConfig, { type }) {
                        if (type === 'server') {
                            serverConfig.entry(_constants.DEFAULT_ENTRY_NAME).add(skeletonEntryPath);
                            // remove some plugins
                            serverConfig.plugins.delete('ssr-server').delete('progress-bar').delete('progress').delete('friendly-error');
                        }
                    }
                });

                // add skeleton plugin
                spaConfig.plugin('skeleton').use(_vueSkeletonWebpackPlugin2.default, [{
                    webpackConfig: skeletonConfig,
                    quiet: true,
                    router: {
                        mode: router.mode,
                        routes: skeleton.routes
                    },
                    minimize: !_this7.isDev
                }]);
            }
        })();
    }

    /**
     * validate skeleton.router.routes
     *
     * @param {Array} routes routes for skeleton
     * @param {Object} alias alias in webpack
     * @return {boolean|Object} error error
     */
    validateSkeletonRoutes(routes, alias) {
        var _this8 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            let currentRoute;
            let resolvedPaths = [];
            let isComponentPathResolved;
            for (let i = 0; i < routes.length; i++) {
                currentRoute = routes[i];

                if (!currentRoute.componentPath) {
                    return {
                        msg: `[Lavas] componentPath for ${currentRoute.path} is required.`
                    };
                }

                // try to resolve componentPath with rootDir and webpack alias
                isComponentPathResolved = false;
                resolvedPaths = [(0, _path.join)(_this8.config.globals.rootDir, currentRoute.componentPath), (0, _path2.resolveAliasPath)(alias, currentRoute.componentPath)];
                for (let j = 0; j < resolvedPaths.length; j++) {
                    if ((0, _fsExtra.pathExistsSync)(resolvedPaths[j])) {
                        // in Windows, normalize will replace posix.sep`/` with win32.sep`\\`
                        currentRoute.componentPath = (0, _path.normalize)(resolvedPaths[j]).replace(/\\/g, '\\\\'); // escape backslash before writing to skeleton template
                        isComponentPathResolved = true;
                        break;
                    }
                }

                if (!isComponentPathResolved) {
                    return {
                        msg: `[Lavas] ${currentRoute.componentPath} is not existed during the process of generating skeleton.`
                    };
                }
            }
            return false;
        })();
    }

    /**
     * create a webpack config which will be compiled later
     *
     * @return {Object} spaConfig webpack config for SPA
     */
    createSPAConfig() {
        var _this9 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            let { globals, router, skeleton } = _this9.config;
            let rootDir = globals.rootDir;

            // create spa config based on client config
            return yield _this9.webpackConfig.client({
                extendWithWebpackChain: (() => {
                    var _ref = (0, _asyncToGenerator3.default)(function* (clientConfig, { type }) {
                        if (type === 'client') {
                            clientConfig.name = 'spaclient';
                            clientConfig.context(rootDir).entry(_constants.DEFAULT_ENTRY_NAME).add('./core/entry-client.js');

                            // add html-webpack-plugin
                            let {
                                resolvedTemplatePath: customTemplatePath,
                                tempTemplatePath
                            } = yield _this9.addHtmlPlugin(clientConfig, router.base);
                            // let customTemplatePath = await this.addHtmlPlugin(clientConfig, router.base);

                            // add vue-skeleton-webpack-plugin
                            if (skeleton && skeleton.enable) {
                                yield _this9.addSkeletonPlugin(clientConfig);
                            }

                            // watch template in development mode
                            if (_this9.isDev) {
                                // watch html
                                _this9.addWatcher(customTemplatePath, 'change', (0, _asyncToGenerator3.default)(function* () {
                                    yield _this9.writeFileToLavasDir(tempTemplatePath, _template2.default.client((yield (0, _fsExtra.readFile)(customTemplatePath, 'utf8')), router.base));
                                }));

                                // enable hotreload in every entry in dev mode
                                yield (0, _webpack.enableHotReload)(_this9.lavasPath(), clientConfig, true);

                                // add skeleton routes
                                if (_this9.skeletonEnabled) {
                                    // TODO: handle skeleton routes in dev mode
                                    // this.addSkeletonRoutes(spaConfig);
                                }
                            }
                        }
                    });

                    return function extendWithWebpackChain(_x, _x2) {
                        return _ref.apply(this, arguments);
                    };
                })()
            });
        })();
    }

    /**
     * create a webpack config which will be compiled later
     *
     * @param {boolean} isDev enable watcher
     * @return {Object} SSRClientConfig webpack config for SSRClient
     */
    createSSRClientConfig() {
        var _this10 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            return yield _this10.webpackConfig.client({
                extendWithWebpackChain: (() => {
                    var _ref3 = (0, _asyncToGenerator3.default)(function* (clientConfig, { type }) {
                        if (type === 'client') {
                            clientConfig.name = 'ssrclient';
                            clientConfig.context(_this10.config.globals.rootDir).entry(_constants.DEFAULT_ENTRY_NAME).add('./core/entry-client.js');

                            // add vue-ssr-client-plugin
                            clientConfig.plugin('ssr-client').use(_clientPlugin2.default, [{
                                filename: (0, _path.join)(_constants.LAVAS_DIRNAME_IN_DIST, _constants.CLIENT_MANIFEST)
                            }]);

                            if (_this10.isDev) {
                                // enable hot-reload
                                yield (0, _webpack.enableHotReload)(_this10.lavasPath(), clientConfig, true);
                            }
                        }
                    });

                    return function extendWithWebpackChain(_x3, _x4) {
                        return _ref3.apply(this, arguments);
                    };
                })()
            });
        })();
    }

    /**
     * create a webpack config which will be compiled later
     *
     * @return {Object} SSRServerConfig webpack config for SSRServer
     */
    createSSRServerConfig() {
        var _this11 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            return yield _this11.webpackConfig.server({
                extendWithWebpackChain: (() => {
                    var _ref4 = (0, _asyncToGenerator3.default)(function* (serverConfig, { type }) {
                        if (type === 'server') {
                            serverConfig.name = 'ssrserver';
                            serverConfig.context(_this11.config.globals.rootDir).entry(_constants.DEFAULT_ENTRY_NAME).add('./core/entry-server.js');
                        }
                    });

                    return function extendWithWebpackChain(_x5, _x6) {
                        return _ref4.apply(this, arguments);
                    };
                })()
            });
        })();
    }
}
exports.default = BaseBuilder;
module.exports = exports['default'];