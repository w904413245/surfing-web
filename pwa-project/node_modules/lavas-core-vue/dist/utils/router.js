'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

exports.routes2Reg = routes2Reg;
exports.matchUrl = matchUrl;
exports.generateRoutes = generateRoutes;

var _path = require('path');

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _pathToRegexp = require('path-to-regexp');

var _pathToRegexp2 = _interopRequireDefault(_pathToRegexp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function routes2Reg(routes) {
    let reg;
    if (typeof routes === 'string') {
        reg = (0, _pathToRegexp2.default)(routes);
    } else if (routes instanceof RegExp) {
        return routes;
    }

    return reg;
} /**
   * @file utils.router.js
   * @author lavas
   */
function matchUrl(routes, url) {
    if (Array.isArray(routes)) {
        return routes.some(route => matchUrl(route, url));
    }

    let reg;
    if (typeof routes === 'string') {
        reg = new RegExp('^' + routes.replace(/\/:[^\/]*/g, '/[^\/]+') + '\/?');
    } else if (typeof routes === 'object' && typeof routes.test === 'function') {
        reg = routes;
    }

    return reg.test(url);
}

/**
 * generate router by the structure of pages/
 *
 * @param {string} baseDir root folder path
 * @param {Object} options generate options
 * @return {Promise} resolve generated router, reject error
 */
function generateRoutes(baseDir, { globOptions, routerOption } = {}) {
    return getDirs(baseDir, '.vue', globOptions).then(dirs => {
        let tree = mapDirsInfo(dirs, baseDir).reduce((tree, info) => appendToTree(tree, info.levels, info), []);
        return treeToRouter(tree[0].children, { dir: (0, _path.basename)(baseDir) }, routerOption);
    });
}

function getDirs(baseDir, ext = '', options) {
    return new _promise2.default((res, reject) => {
        (0, _glob2.default)((0, _path.resolve)(baseDir, '**/*' + ext), options, (err, dirs) => {
            if (err) {
                reject(err);
            } else {
                // ['/pages/a/b/c'] => ['/pages/a', '/pages/a/b', '/pages/a/b/c'] when baseDir is /pages
                let set = dirs.reduce((set, dir) => {
                    let levels = dir.slice(baseDir.length + 1).split('/');
                    let newDir = baseDir;

                    for (let i = 0; i < levels.length; i++) {
                        newDir += '/' + levels[i];
                        set.add(newDir);
                    }

                    return set;
                }, new _set2.default());

                res((0, _from2.default)(set).sort((a, b) => a.localeCompare(b)));
            }
        });
    });
}

function mapDirsInfo(dirs, baseDir) {
    let baseFolder = (0, _path.basename)(baseDir);
    // remove useless baseDir
    dirs = dirs.map(dir => baseFolder + dir.slice(baseDir.length));

    let infos = dirs.reduce((list, dir) => {
        let type;

        if ((0, _path.extname)(dir) === '.vue') {
            let regex = new RegExp(`^${dir.slice(0, -4)}$`, 'i');

            if (dirs.some(d => regex.test(d))) {
                type = 'nested';
            }
        } else {
            let regex = new RegExp(`^${dir}.vue$`, 'i');

            if (dirs.some(d => regex.test(d))) {
                return list;
            }

            type = 'flat';
        }

        dir = dir.replace(/\.vue$/, '');
        let levels = dir.split('/');

        list.push({
            dir,
            type,
            levels
        });

        return list;
    }, []).sort((a, b) => a.dir.localeCompare(b.dir));

    return infos;
}

function appendToTree(tree, levels, info) {
    let levelLen = levels.length;
    let node = tree;

    for (let i = 0; i < levelLen; i++) {
        let nodeLen = node.length;
        let regex = new RegExp(`^${levels[i]}$`, 'i');
        let j;

        for (j = 0; j < nodeLen; j++) {
            if (regex.test(node[j].name)) {
                if (i === levelLen - 1) {
                    node[j].info = info;
                } else {
                    node[j].children = node[j].children || [];
                    node = node[j].children;
                }

                break;
            }
        }

        if (j === nodeLen) {
            if (i === levelLen - 1) {
                node.push({
                    name: levels[i],
                    info: info
                });
            } else {
                node.push({
                    name: levels[i],
                    children: []
                });
                node = node[j].children;
            }
        }
    }

    return tree;
}

function treeToRouter(tree, parent, { pathRule = 'kebabCase' } = {}) {
    let rr = tree.reduce((router, { info, children }) => {
        if (info.type === 'flat') {
            return router.concat(treeToRouter(children, parent, { pathRule }));
        }

        let route = {
            path: generatePath(info, parent, pathRule),
            component: info.dir + '.vue'
        };

        if (!children || children.every(child => !/(\/index)+$/i.test(child.info.dir))) {
            route.name = generateName(info.dir);
        }

        if (children) {
            route.children = treeToRouter(children, info, { pathRule });
        }

        router.push(route);
        return router;
    }, []);

    return rr;
}

function generatePath(info, parent, rule) {
    let path = info.dir.slice(parent.dir.length).replace(/(^|\/)_/g, '$1:').replace(/((^|\/)index)+$/i, '');

    switch (rule) {
        case 'raw':
            break;

        case 'camelCase':
            path = path.replace(/(^|\/)([A-Z]+)/g, (full, w1, w2) => `${w1}${w2.toLowerCase()}`);

        case 'lowerCase':
            path = path.replace(/(^|\/)([^:\/]+)/g, (full, w1, w2) => full.toLowerCase());

        default:
            // default is kebabCase
            path = path.replace(/(^|\/)([^:\/]+)/g, (full, w1, w2) => w1 + w2.replace(/([a-z0-9])([A-Z]+)/g, '$1-$2').toLowerCase());
    }

    if (parent.type === 'nested') {
        path = path.replace(/^\//, '');
    } else if (path === '') {
        path = '/';
    }

    return path;
}

function generateName(dir) {
    let name = dir.replace(/((^|\/)index)+$/i, '').split('/').slice(1).map((name, i) => {
        name = name.replace(/(^|\/)_/, '');

        if (i === 0) {
            return name.replace(/^[A-Z]+/, w => w.toLowerCase());
        }

        return name.replace(/^[a-z]/, w => w.toUpperCase());
    }).join('');

    return name || 'index';
}