'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RUMTIME_ITEMS = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _fsExtra = require('fs-extra');

var _path = require('path');

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _lodash = require('lodash');

var _constants = require('./constants');

var _path2 = require('./utils/path');

var _json = require('./utils/json');

var JsonUtil = _interopRequireWildcard(_json);

var _logger = require('./utils/logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @file ConfigReader
 * @author *__ author __*{% if: *__ email __* %}(*__ email __*){% /if %}
 */

function mergeArray(a, b) {
    if ((0, _lodash.isArray)(a)) {
        return a.concat(b);
    }
}

const DEFAULT_CONFIG = {
    buildVersion: null,
    build: {
        ssr: true,
        publicPath: '/',
        filenames: {
            entry: 'js/[name].[chunkhash:8].js',
            vendor: 'js/vendor.[chunkhash:8].js',
            vue: 'js/vue.[chunkhash:8].js',
            chunk: 'js/[name].[chunkhash:8].js',
            css: 'css/[name].[contenthash:8].css',
            img: 'img/[name].[hash:8].[ext]',
            fonts: 'fonts/[name].[hash:8].[ext]'
        },
        babel: {
            babelrc: false
        },
        cssExtract: false,
        cssMinimize: true,
        cssSourceMap: true,
        jsSourceMap: true,
        bundleAnalyzerReport: false,
        compress: false,
        defines: {
            base: {},
            client: {},
            server: {}
        },
        alias: {
            base: {},
            client: {},
            server: {}
        },
        plugins: {
            base: [],
            client: [],
            server: []
        },
        nodeExternalsWhitelist: [],
        watch: null,
        extend: null,
        ssrCopy: [],
        // https://doc.webpack-china.org/configuration/stats/
        stats: {
            assetsSort: 'name',
            chunks: false,
            children: true,
            modules: false,
            colors: true,
            timings: true,
            excludeAssets: [/.map$/, /.html$/]
        }
    },
    skeleton: {
        enable: true,
        asyncCSS: true
    },
    router: {},
    errorHandler: {
        defaultErrorMessage: 'Internal Server Error',
        showRealErrorMessage: false,
        errorPath: '/error'
    },
    middleware: {
        all: [],
        server: [],
        client: []
    },
    serviceWorker: {
        enable: false
    },
    production: {
        build: {
            cssExtract: true,
            compress: true
        }
    },
    development: {
        build: {
            filenames: {
                entry: 'js/[name].[hash:8].js'
            },
            babel: {
                cacheDirectory: true
            }
        }
    }
};

/**
 * config items used in runtime, which will be injected in .lavas/config.json
 */
const RUMTIME_ITEMS = exports.RUMTIME_ITEMS = {
    buildVersion: true,
    build: {
        ssr: true,
        publicPath: true,
        compress: true,
        cssExtract: true
    },
    middleware: true,
    router: true,
    errorHandler: true,
    serviceWorker: {
        enable: true,
        swDest: true
    },
    skeleton: true
};

class ConfigReader {
    constructor(cwd, env, customConfigPath) {
        this.cwd = cwd;
        this.env = env;
        // fix https://github.com/lavas-project/lavas/issues/50
        if (customConfigPath !== 'dev') {
            this.customConfigPath = customConfigPath;
        }
    }

    mergeEnv(config) {
        if (config[this.env]) {
            (0, _lodash.merge)(config, config[this.env], mergeArray);
        }
    }

    /**
     * generate a config object according to config directory and NODE_ENV
     *
     * @return {Object} config
     */
    read() {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            let config = {};

            // merge with default options
            (0, _lodash.merge)(config, DEFAULT_CONFIG, {
                globals: {
                    rootDir: _this.cwd
                },
                buildVersion: Date.now()
            }, mergeArray);

            _this.mergeEnv(config);

            // read from custom config
            if (_this.customConfigPath) {
                _logger2.default.info('build', `Read customized config file: ${_this.customConfigPath}...`, true);
                delete require.cache[require.resolve(_this.customConfigPath)];

                let customConfig = yield _promise2.default.resolve().then(() => require(`${_this.customConfigPath}`));
                _this.mergeEnv(customConfig);
                (0, _lodash.merge)(config, customConfig, mergeArray);

                return config;
            }

            // read from lavas.config.js
            let singleConfigPath = (0, _path.join)(_this.cwd, _constants.LAVAS_CONFIG_FILE);
            if (yield (0, _fsExtra.pathExists)(singleConfigPath)) {
                _logger2.default.info('build', 'Reading lavas.config.js...', true);
                delete require.cache[require.resolve(singleConfigPath)];

                let singleConfig = yield _promise2.default.resolve().then(() => require(`${singleConfigPath}`));
                _this.mergeEnv(singleConfig);
                (0, _lodash.merge)(config, singleConfig, mergeArray);

                _logger2.default.info('build', 'Reading complete', true);
                return config;
            }

            // read from config/
            _logger2.default.warn('build', 'Reading config from `config` directory is DEPRECATED!ï¼ŒPlease write config into `lavas.config.js`');
            let configDir = (0, _path.join)(_this.cwd, 'config');
            let files = _glob2.default.sync('**/*.js', {
                cwd: configDir
            });

            // require all files and assign them to config recursively
            yield _promise2.default.all(files.map((() => {
                var _ref = (0, _asyncToGenerator3.default)(function* (filepath) {
                    filepath = filepath.substring(0, filepath.length - 3);

                    let paths = filepath.split('/');

                    let name;
                    let cur = config;
                    for (let i = 0; i < paths.length - 1; i++) {
                        name = paths[i];
                        if (!cur[name]) {
                            cur[name] = {};
                        }

                        cur = cur[name];
                    }

                    name = paths.pop();

                    // load config, delete cache first
                    let configPath = (0, _path.join)(configDir, filepath);
                    delete require.cache[require.resolve(configPath)];
                    let exportContent = yield _promise2.default.resolve().then(() => require(`${configPath}`));
                    cur[name] = typeof exportContent === 'object' && exportContent !== null ? (0, _lodash.merge)(cur[name], exportContent, mergeArray) : exportContent;
                });

                return function (_x) {
                    return _ref.apply(this, arguments);
                };
            })()));

            _this.mergeEnv(config);

            _logger2.default.info('build', 'finish reading config.', true, true);

            return config;
        })();
    }

    /**
     * in prod mode, read config.json directly instead of analysing config directory
     *
     * @return {Object} config
     */
    readConfigFile() {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            _logger2.default.info('build', 'Reading config...', true);
            let parsedConfig = JsonUtil.parse((yield (0, _fsExtra.readFile)((0, _path2.distLavasPath)(_this2.cwd, _constants.CONFIG_FILE), 'utf8')));
            parsedConfig.globals = { rootDir: _this2.cwd };
            _logger2.default.info('build', 'Reading config complete', true, true);
            return parsedConfig;
        })();
    }
}
exports.default = ConfigReader;