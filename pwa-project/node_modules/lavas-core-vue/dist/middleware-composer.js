'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _path = require('path');

var _fsExtra = require('fs-extra');

var _url = require('url');

var _path2 = require('./utils/path');

var _constants = require('./constants');

var _composeMiddleware = require('compose-middleware');

var _express = require('express');

var _serveStatic = require('serve-static');

var _serveStatic2 = _interopRequireDefault(_serveStatic);

var _serveFavicon = require('serve-favicon');

var _serveFavicon2 = _interopRequireDefault(_serveFavicon);

var _compression = require('compression');

var _compression2 = _interopRequireDefault(_compression);

var _ssr = require('./middlewares/ssr');

var _ssr2 = _interopRequireDefault(_ssr);

var _koaError = require('./middlewares/koa-error');

var _koaError2 = _interopRequireDefault(_koaError);

var _expressError = require('./middlewares/express-error');

var _expressError2 = _interopRequireDefault(_expressError);

var _static = require('./middlewares/static');

var _static2 = _interopRequireDefault(_static);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// enum of internal middlewares
/**
 * @file MiddlewareComposer.js
 * @author lavas
 */

const INTERNAL_MIDDLEWARE = {
    TRAILING_SLASH: 'trailing-slash',
    STATIC: 'static',
    SERVICE_WORKER: 'service-worker',
    FAVICON: 'favicon',
    COMPRESSION: 'compression',
    SSR: 'ssr',
    ERROR: 'error'
};

const ALL_MIDDLEWARES = (0, _keys2.default)(INTERNAL_MIDDLEWARE).map(key => INTERNAL_MIDDLEWARE[key]);

class MiddlewareComposer {
    constructor(core) {
        this.core = core;
        this.cwd = core.cwd;
        this.config = core.config;
        this.isProd = core.isProd;
        this.internalMiddlewares = [];
    }

    add(middleware, head = false) {
        if (typeof middleware !== 'function') {
            throw new Error('Middleware must be a function.');
        }
        if (head) {
            this.internalMiddlewares.unshift(middleware);
        } else {
            this.internalMiddlewares.push(middleware);
        }
    }

    reset(config) {
        this.config = config;
        this.internalMiddlewares = [];
    }

    /**
     * setup some internal middlewares
     *
     */
    setup() {
        if (this.config.build && this.config.build.compress) {
            // gzip compression
            this.add((0, _compression2.default)());
        }
        // serve favicon
        let faviconPath = _path.posix.join(this.cwd, _constants.ASSETS_DIRNAME_IN_DIST, 'img/icons/favicon.ico');
        this.add((0, _serveFavicon2.default)(faviconPath));
    }

    /**
     * compose middlewares into a chain.
     * NOTE: MUST be called in Node >= 7.6.0 because of "async" syntax.
     *
     * @param {Array<Function>|Function} selectedMiddlewares middlewares selected by user
     * @return {Function} koaMiddleware
     */
    koa(selectedMiddlewares = ALL_MIDDLEWARES) {
        var _this = this;

        if (!Array.isArray(selectedMiddlewares)) {
            selectedMiddlewares = [selectedMiddlewares];
        }

        const composeKoa = require('koa-compose');
        const c2k = require('koa-connect');
        const mount = require('koa-mount');
        const koaStatic = require('koa-static');
        const send = require('koa-send');

        let { router: { base }, build: { ssr, publicPath }, serviceWorker, errorHandler } = this.config;
        base = (0, _path2.removeTrailingSlash)(base || '/');

        if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.COMPRESSION)) {
            // gzip compression
            this.add((0, _compression2.default)());
        }

        if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.FAVICON)) {
            // serve favicon
            let faviconPath = _path.posix.join(this.cwd, _constants.ASSETS_DIRNAME_IN_DIST, 'img/icons/favicon.ico');
            if ((0, _fsExtra.existsSync)(faviconPath)) {
                this.add((0, _serveFavicon2.default)(faviconPath));
            }
        }

        // transform express/connect style middleware to koa style
        this.internalMiddlewares = this.internalMiddlewares.map(c2k);

        // koa defaults to 404 when it sees that status is unset
        this.add((() => {
            var _ref = (0, _asyncToGenerator3.default)(function* (ctx, next) {
                ctx.status = 200;
                yield next();
            });

            return function (_x, _x2) {
                return _ref.apply(this, arguments);
            };
        })(), true);

        // handle errors
        if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.ERROR)) {
            this.add((0, _koaError2.default)(errorHandler), true);
        }

        // Redirect without trailing slash.
        if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.TRAILING_SLASH)) {
            this.add((() => {
                var _ref2 = (0, _asyncToGenerator3.default)(function* (ctx, next) {
                    if (base === ctx.path) {
                        ctx.redirect(`${ctx.path}/${ctx.search}`);
                    } else {
                        yield next();
                    }
                });

                return function (_x3, _x4) {
                    return _ref2.apply(this, arguments);
                };
            })());
        }

        if (ssr) {
            /**
             * Add static files middleware only in prod mode,
             * because we already have webpack-dev-middleware in dev mode.
             * Don't need this middleware when CDN being used to serve static files.
             */
            if (this.isProd && !(0, _path2.isFromCDN)(publicPath)) {

                if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.STATIC)) {
                    // serve /static
                    this.add(mount(_path.posix.join(publicPath, _constants.ASSETS_DIRNAME_IN_DIST), koaStatic((0, _path.join)(this.cwd, _constants.ASSETS_DIRNAME_IN_DIST))));
                }

                // serve sw-register.js & sw.js
                if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.SERVICE_WORKER) && serviceWorker && serviceWorker.swDest) {
                    let swFiles = [(0, _path.basename)(serviceWorker.swDest), 'sw-register.js'].map(f => _path.posix.join(publicPath, f));
                    this.add((() => {
                        var _ref3 = (0, _asyncToGenerator3.default)(function* (ctx, next) {
                            let done = false;
                            if (swFiles.includes(ctx.path) || /^\/precache\-manifest.+\.js$/.test(ctx.path)) {
                                // Don't cache service-worker.js & sw-register.js & precache-manifest.js.
                                ctx.set('Cache-Control', 'private, no-cache, no-store');
                                done = yield send(ctx, ctx.path.substring(publicPath.length), {
                                    root: _this.cwd
                                });
                            }
                            if (!done) {
                                yield next();
                            }
                        });

                        return function (_x5, _x6) {
                            return _ref3.apply(this, arguments);
                        };
                    })());
                }
            }

            if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.SSR)) {
                this.add(c2k((0, _ssr2.default)(this.core)));
            }
        }

        return composeKoa(this.internalMiddlewares);
    }

    /**
     * compose middlewares into a chain.
     *
     * @param {Array<Function>|Function} selectedMiddlewares middlewares selected by user
     * @return {Function} expressMiddleware
     */
    express(selectedMiddlewares = ALL_MIDDLEWARES) {
        if (!Array.isArray(selectedMiddlewares)) {
            selectedMiddlewares = [selectedMiddlewares];
        }

        let expressRouter = _express.Router;
        let { router: { base }, build: { ssr, publicPath }, serviceWorker, errorHandler } = this.config;
        base = (0, _path2.removeTrailingSlash)(base || '/');

        if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.COMPRESSION)) {
            // gzip compression
            this.add((0, _compression2.default)());
        }

        if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.FAVICON)) {
            // serve favicon
            let faviconPath = _path.posix.join(this.cwd, _constants.ASSETS_DIRNAME_IN_DIST, 'img/icons/favicon.ico');
            this.add((0, _serveFavicon2.default)(faviconPath));
        }

        if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.TRAILING_SLASH)) {
            // Redirect without trailing slash.
            let rootRouter = expressRouter();
            rootRouter.get(base, (req, res, next) => {
                let url = (0, _url.parse)(req.url);
                if (!url.pathname.endsWith('/')) {
                    res.redirect(301, url.pathname + '/' + (url.search || ''));
                } else {
                    next();
                }
            });
            this.add(rootRouter, true);
        }

        if (ssr) {
            /**
             * Add static files middleware only in prod mode,
             * because we already have webpack-dev-middleware in dev mode.
             * Don't need this middleware when CDN being used to serve static files.
             */
            if (this.isProd && !(0, _path2.isFromCDN)(publicPath)) {
                // Serve /static.
                if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.STATIC)) {
                    let staticRouter = expressRouter();
                    staticRouter.get(_path.posix.join(publicPath, _constants.ASSETS_DIRNAME_IN_DIST, '*'), (0, _static2.default)(publicPath));
                    this.add(staticRouter);
                    // Don't use etag or cache-control.
                    this.add((0, _serveStatic2.default)(this.cwd, {
                        cacheControl: false,
                        etag: false
                    }));
                }

                // Serve sw-register.js & sw.js.
                if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.SERVICE_WORKER)) {
                    if (serviceWorker && serviceWorker.swDest) {
                        let swFiles = [(0, _path.basename)(serviceWorker.swDest), 'sw-register.js'].map(f => _path.posix.join(publicPath, f));
                        let swRouter = expressRouter();
                        swRouter.get(swFiles, (0, _static2.default)(publicPath));
                        this.add(swRouter);
                        // Use cache-control but not etag.
                        this.add((0, _serveStatic2.default)(this.cwd, {
                            etag: false
                        }));
                    }
                }
            }

            // SSR middleware.
            if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.SSR)) {
                this.add((0, _ssr2.default)(this.core));
            }
        }

        // Handle errors.
        if (selectedMiddlewares.includes(INTERNAL_MIDDLEWARE.ERROR)) {
            this.add((0, _expressError2.default)(errorHandler));
        }

        return (0, _composeMiddleware.compose)(this.internalMiddlewares);
    }
}
exports.default = MiddlewareComposer;
module.exports = exports['default'];